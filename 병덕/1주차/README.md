# JAVA STUDY 연습

## 0) 자바의 기본 프로그램 구조
![Alt text](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSors4VmugvIi49W8rMxpmxtjL2RAWpc0Altg&usqp=CAU)
* 클래스(class)
</br>
클래스는 프로그램을 개발하는 단위로 적어도 하나의 클래스가 있어야한다.
자바의 소스 파일은 클래스 이름과 연관되기 때문에 이클립스로 Hello를 생성하면 Hello. java라는 소스파일이 생성
클레스 이름은 대문자로 시작하며, 
클래스 내부에는 여러개의 메소드가 포함 될 수 있다.
</br>
* 메소드(method)
</br>
수행할 작업을 나열한 코드의 모임이다. 
* 자바 애플리케이션은 main() 메서드 부터 실행을 시작하므로 main() 메소드를 포함하는 클래스가 있어야한다.
* 실행문(statement)
</br>
작업을 지시하는 변수 선언, 값 저장, 메소드 호출 등의 코드를 의미한다. 
* 주석문
프로그램을 덧붙이는 설명문으로 컴파일러가 무시하는 문장이다.

## 1) 변수
### 1.변수의 개념
프로그램은 메모리 공간에 데이터를 보관하고, 여러 메모리 공간을 변수로 구분한다.
</br>
변수는 데이터를 담는 상자 역할을 하며, 종류가 다양한데, 이를 구분하려고 데이터 타입을 사용한다.
</br>
데이터 타입에 따라 가능한 값, 수행할 수 있는 명령, 데이터의 의미 저장하는 방식이 달라지고, 특정 타입의 변수 상자에는 해당 타입의 데이터만 저장 할 수 있다.
</br>
프로그램 내부에서 값을 정의해 변수를 초기화할 수 있는데, 그 값을 리터럴이라고 한다.
### 2. 데이터 타입
* 정수
</br>
정수는 기본적으로 int 타입이고 값의 범위에 따라 byte,short,long을 사용한다.
```agsl
int fifteen = 15;   //10진수
int fifteen = 0b1111; //2진수 15
int fifteen = 017 // 8진수 15
int fifteen = 0xF // 16진수 15
long lightSpeed = 300000L; // L은 long 타입임을 명시
```
* 실수
</br>
실수는 기본적으로 double 타입이고 값의 범위에 따라 float 타입을 사용한다.
```agsl
double half = 0.5; //일반표기법
double half = 5E-1; // 지수 표기법으로 5X10^1을 의미
float pi = 3.14159; // 오류
float pi = 3.14159F; // F는 float 타입임을 명시
double pi = 3.14159;
```
- 예제 참고 

* 문자
</br> 문자는 char 타입을 사용함.
</br> 유니코드는 0~65,535 정수로 표현하기 때문에 char 타입은 일종의 정수 타입.
</br> 2바이트 문자 처리 방식인 유니코드를 사용함.
```agsl
char c = 'A'; //문자
char c = 65; // 일종의 정수 타입이기 때문에 65 대입 가능
char c = '\u0041' // 유니코드 값으로 대입
char c = "A"; // "A"는 문자가 아니라 문자열이므로 오류
```

| 표현    | 제어문자                      |  유니코드  |
|-------|:--------------------------|:------:|
| '\b'  | Backspace                 | \u0008 |
| '\t'  | Tap                       | \u0009 |
| '\n'  | 한 행 넘김(line feed)         | \u000a |
| '\r'  | 맨 앞으로 이동(carriage return) | \u000d |
| '\\'' | '                         | \u0022 |
| '\\"' | "                         | \u0027 |
| '\\\\' | \                         | \u005c |

* 논리
</br> 논리값은 boolean 타입을 사용
</br> 논리 리터럴은 두 가지 상태인 true와 false로 표현한다.

``boolean condition = true; // 논리 리터럴 true와 flase 중 하나``
- 문자 및 논리 타입 응용 예제

### 3. 변수 사용
* 변수를 사용하려면 컴파일러에 어떤 데이터 타입을 쓸지 알려야함
* 변수에 저장할 데이터 타입을 지저앟고 이름을 붙이는 것 = 변수 선언
* 실행문이기 때문에 세미콜론(;) 사용
* 데이터 타입이 같은 변수는 쉼포(,)로 연결 가능
```agsl
int weight; // 정수 타입의 weight 변수 선언
double x,y,z; // 3개의 변수를 ,로 연결해 선언
int a = 50; // 변수 선언과 초기화는 동시에 가능
```

* 초깃값을 통하여 데이터 타입을 추론할 수 있는 var이라는 예약어를 지원함.
* 키워드가 아니기 때문에 식별자로 사용
* var은 초깃값을 통하여 데이터 타입을 추론할 수 있고 메소드 내부에 있는 변수에 대해서만 사용
```agsl
var number = 100; // var은 정수를 나타낼 수 있는 타입 int로 추론
var korean = "한국"; // var은 문자열을 나타낼 수 있는 타입 String으로 추론
var oops; // 초깃값이 없으므로 타입 추론 실패 = 오류
```

### 4. 상수
* 상수는 프로그램 실행 도중 변경할 수 없는 데이터를 담는 변수이다.
</br> ex) 원주율 값은 변하기 않기 때문에 상수로 선언하면 좋음.
* 상수는 변수와 달리 한 번 값을 저장하면 다른 값으로는 저장 불가.
* 대문자 표기 !
* final 키워드로 지정해야 함.
 >
>  > 상수는 프로그램 실행 중 항상 동일한 값을 가지는 변수이고 , 상수는 리터럴에 의미 있는 이름을 붙여서 코드의 가독성을 높이고 , 쉽게 수정할 수 있게 한다.

`` final double PI = 3.14159 // 변수와 동일하게 초기화 가능``

### 5. 타입 변환
* int 타입의 데이터를 float 타입으로 변경할 수 있음.
* 데이터 타입을 바꾸는 연산을 타입 변환이라고 함.
* 자동과 강제 타입 변환 2가지 종류가 있음.

#### 자동 타입 변환
- 프로그램 실행 중에 자동으로 타입이 변환되는 것을 의미
- 자동 타입 변환은 연산식이나 실행문에서 서로 다른 데이터 타입이 나타날 때 발생

EX) 정수와 실수를 연사나할 때는 먼저 정수를 큰 데이터 타입인 실수로 변환한 후 연산이나 대입을 수행
```agsl
double d1 = 5*3.14; // 정수 5를 실수 5.0로 자동 타입 변환
double d2 = 1; // 정수 1을 실수 1.0으로 자동 타입 변환
```

#### 강제 타입 변환
- 타입 변환 연산자를 사용해 데이터 타입을 강제로 변환하는 연산이다.
- 타입 변환은 다음에 같이 데이터 앞에 '(데이터타입)' 형태의 타입 변환 연산자를 붙힘.
```agsl
// double의 3.14를 float로 형 변환해 f에 3.14F 저장
float f = (float)3.14;

// int의 300을 byte로 형 변환하면 데이터가 손실되고 3만 저장
byte b = (byte)300;

// double의 3.14를 byte로 형 변환하면 데이터가 손실되고 3만 저장
byte x = (byte)3.14;

// float의 3.14를 double로 형 변환하면 데이터 손실 없이 저장
double d = (double)3.14f;
```

## 4) 자바 기본 입출력
### 1. 화면에 데이터 출력
출력은 모두 System.out 객체와 연결하여 사용

* println() : ()내부의 내용을 출력한 후 행을 바꿈.
* print() : ()내부의 내용을 출력만 하고 행은 바꾸지 않음.
* printf() : ()내부의 내용을 지정된 포맷을 사용해 출력함.

```agsl
//System.out.printf("포맷 명시자",데이터,데이터,...);

int x = 5;
double pi = 3.14;

System.out.printf("x =%d and pi = %f\n, x, pi); // x변수를 십진수 정수 포맷과 대응(pi도 동일)
```
![Alt text](https://slidesplayer.org/slide/16756540/97/images/23/%EA%B8%B0%EB%B3%B8+%EC%9E%85%EC%B6%9C%EB%A0%A5+printf%28%29%EC%9D%98+%ED%8F%AC%EB%A7%B7%EA%B3%BC+%EC%8B%A4%ED%96%89+%EA%B2%B0%EA%B3%BC.jpg)

### 2. 키보드로 데이터 입력
1. 프로그램의 첫 행에 다음을 추가해 Scanner 클래스의 경로 이름을 컴파일러에 알림.

`` import java.until.Scanner;``
2. 키보드로 데이터를 입력 받으려 Scanner 객체를 생성함.

``Scanner in = new Scanner(Ststem.in);``

3. Scanner 클래스가 제공하는 다양한 메서드를 이용해 키보드로 데이터를 입력받음.

`` int x = in.nextInt(); //정수를 읽어 x변수에 대입``

| 메서드          | 반환타입   |
|--------------|:-------|
| next()       | String |
| nextByte()   | byte   |
| nextShort()  | short  |
| nextInt()    | int    |
| nextLong()   | long   |
| nextFloat()  | float  |
| nextDouble() | double |
| nextLine()   | String |
- 입력 메소드

## 5) 연산자
### 1. 연산자와 연산식 개념

* 프로그램에서 주어진 데이터를 계산해 결과를 얻어 내는 과정을 연산
* 연산에서 사용하는 기호(+,*,<=)를 연산자
* 연산되는 데이터 (x,y,z)를 피연산자
* 연산식은 변수,상수,메소드 등 피연산자와 연산자의 조합
</br>
- 자바 연산자의 종류

| 종류  | 연산자                                 | 설명                         | 비고    |
|-----|:------------------------------------|----------------------------|-------|
| 증감  | ++,--                               | 1만큼 증가또는 감소한다.             | 단항    |
| 산술  | +,-,*,/,%                           | 사칙연산과 모듈로 연산한다.            | 이항    |
| 시프트 | >>,<<,>>>                           | 비트를 좌우로 이동한다.              | 이항    |
| 부호  | +,-                                 | 부호를 변환한다.                  | 단항    |
| 비교  | >,<,>=,<=,==,!=                     | 데이터 값을 비교하거나 데이터 타입을 비교한다. | 이항    |
| 비트  | &,ㅣ,~,^                             | 비트 단위의 AND,OR,NOT,XOR      | 단항,이항 |
| 논리  | &&,ㅣㅣ,!,^                           | 논리적 AND,OR,NOT,XOR         | 단항,이항 |
| 조건  | (expr) ? x:y                        | expr에 따라 x 또는 y로 값을 결정한다.  | 삼항    |
| 대입  | =,+=,-=,*=,/=,&=,ㅣ=,^=,>>=,<<=,>>>= | 오른쪽 값을 연산해 왼쪽에 대입한다.       | 이항    |

### 2. 산술 연산자
* 산술 연산자는 수식 계산에 사용
* 두 피연산자의 데이터 타입이 다르면 큰 범위의 타입으로 일치시킨 후 연산 수행
* 논리 타입을 제외한 기초 타입을 피연산자로 사용할 수 있다. 단 % 연산자는 정수 타입에만 사용
* 덧셈 연산자는 문자열을 연결하는 데도 사용
* 문자열과 덧셈을 하는 데이터는 먼저 문자열로 변환한 후 서로 연결
* % 연산자는 다음과 같이 나눗셈을 수행한 후 나머지 산출

```agsl
// 짝수와 홀수 여부 판단. n이 홀수면 a가 1, 짝수면 a는 0
int a = n%2;

// 3의 배수인지 확인, n이 3의 배수면 b가 0, 아니면 b는 0이 아님
int b = n%3;
```
-예제

### 3. 비교 논리 연산자

* 비교 연산자는 2개의 피연산자를 비교해 결괏값으로 논리값인 true나 flase를 되돌려 준다.

| 연산자  | 사용 예   | 설명               |
|------|:-------|------------------|
| ==   | x == y | x와 y는 같은가 ?      |
| !=   | x != y | x와 y는 다른가 ?      |
| ">"  | x > y  | x는 y보다 큰가?       |
| ">=" | x >= y | x는 y보다 크거나 같은가 ? |
| "<"  | x < y  | x는 y보다 작은가?      |
| "<=" | x <= y | x는 y보다 작거나 같은가 ? |

* 논리 연산자는 피연산자의 조건을 결합해서 true와 flase를 조사하며, 논리타입에만 사용


| a   | b      | !a    | a&&b | aㅣㅣb | a^b |
|-----|:-------|-------|------|------|-----|
| false | false  | true  |  false    |  false    |false     |
| false    |true |   true    |  false    |  true    | true    |
| true | false       | false |     false | true     |  true   |
| true | true | false | true     |   true   |   false  |
 * 논리 연산자 예시

### 4.비트 , 시프트 연산자

* 비트 연산자와 시프트 연산자는 정수 타입에만 사용하며, 비트 단위로 연산을 수행

| 연산자 | 설명                                |
|----|-----------------------------------|
| &  | 두 비트가 모두 1일 때만 1 이며, 나머지는 모두 0이다. |
| ㅣ  | 두 비트가 모두 1일 때만 1 이며, 나머지는 모두 0이다. |
| ^  | 두 비트가 서로 다를 때는 1, 둥일할 때는 0이다.     |
| ~  | 1을 0으로, 0을 1로 바꾼다.                |

- 시프트 연산자

| 연산자  | 피연산자 a와 b로 연산할 경우(예를 들어 a <<b)                                          |
|------|-------------------------------------------------------------------------|
| <<   | a의 모든 비트를 왼쪽으로 b비트 만큼 이동하며, 이동할 때마다 최하위 비트를 0으로 채운다<br/>곱셈 효과가 나타남.     |
| ">>" | a의 모든 비트를 오른쪽으로 b만큼 이동하며, 이동할 때마다 최상위 비트와 동일한 비트로 채운다<br/> 나눗셈 효과가 나타남. |
| ">>>" | a의 모든 비트를 오른쪽으로 b비트만큼 이동하며, 이동할때마다 최상위 비트를 0으로 채운다, 산술적 효과 X            |

### 5.대입 연산자
* 오른쪽에 있는 연산식의 결괏값을 왼쪽에 있는 변수에 저장
* 오른쪽에는 값이 될수 있는 리터럴, 변수나 연산식이 오지만 왼쪽에는 변수만 옴
* 오른쪽 변수는 값을 나타내지만, 왼쪽 변수는 값을 저장할 공간을 의미함.

```agsl
int weight = 50; 
weight = weight + 10; // 왼쪽 변수는 데이터를 보관하는 상자를 의미, 오른쪽 변수는 데이터를 의미, 따라서 왼쪽 변수는 60을 저장할 상자임
```

* 다른 연산자와 합친 복합 대입 연산자의 종류

| 연산자  | 설명           |
|------|:-------------|
| a+= b | a = a+b와 동일  |
| a-= b | a = a-b와 동일  |
| a*= b | a = a*b와 동일  |
| a/= b | a = a/b와 동일  |
| a%= b | a = a%b와 동일  |
| a&= b | a = a&b와 동일  |
| aㅣ=b | a = aㅣb와 동일  |
| a^= b | a = a^b와 동일  |
| a>>= b | a = a>>b와 동일 |
| a<<= b | a = a<<b와 동일 |

### 6. 부호, 증감 연산자
* 부호 연산자는 숫자를 나타내는 기초 타입에 사용
*  피연산자의 부호를 유지하거나 반전시킴

- 부호 연산자 

| 연산자 | 설명    |
|-----|:------|
| +   | 부호 유지 |
| -   | 부호 반전 |

- 증감 연산자
* 변숫값을 1 증가하거나 감소하는 연산자
* 논리 타입을 제외한 기초 타입에 사용

| 연산자   | 설명                  |
|-------|:--------------------|
| 변수 ++ | 연산 후 x 값 증가 (후위 증가) |
| ++ 변수 | 연산 전 x 값 증가 (전위 증가) |
| 변수 -- | 연산 후 x 값 감소 (후위 감소) |
| -- 변수 | 연산 전 x 값 감소 (전위 감소) |

### 7. 조건 연산자

* 조건식이 ture이면 결괏값은 연산식 1의 값이 됨
* 조건식이 flase이면 결괏값은 연산식2의 값이 됨

`` 조건식 ? 연산식1 : 연산식 2``

- trenaryoperator 예제

### 8. 연산자 우선순위

![Alt text](http://hongong.hanbit.co.kr/wp-content/uploads/2021/11/%EC%9E%90%EB%B0%94_%EC%97%B0%EC%82%B0%EC%9D%98_%EB%B0%A9%ED%96%A5%EA%B3%BC_%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84.png)

- 연산자 우선순위의 표 정리

